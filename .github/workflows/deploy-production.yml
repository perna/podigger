name: Deploy to Production

on:
  push:
    branches:
      - main
  workflow_dispatch:  # Keep manual option for emergency deployments
    inputs:
      branch:
        description: 'Branch to deploy'
        required: true
        default: 'main'
        type: string
      skip_backup:
        description: 'Skip database backup'
        required: false
        default: false
        type: boolean

permissions:
  contents: read

jobs:
  deploy-production:
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://podigger.perna.app
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'workflow_dispatch' && inputs.branch || 'main' }}
      
      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.VPS_SSH_KEY }}
      
      - name: Add VPS to known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts
      
      - name: Backup database
        if: ${{ github.event_name == 'push' || !inputs.skip_backup }}
        run: |
          echo "üì¶ Creating database backup..."
          ssh -o ServerAliveInterval=60 -o ServerAliveCountMax=10 ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'ENDSSH'
            cd /opt/podigger-production
            
            # Create backup directory if not exists
            mkdir -p backups
            
            # Create backup
            BACKUP_FILE="backups/backup-$(date +%Y%m%d-%H%M%S).sql.gz"
            docker compose -f docker-compose.production.yml exec -T db-production \
              pg_dump -U podigger_production podigger_production | gzip > "$BACKUP_FILE"
            
            echo "‚úÖ Backup created: $BACKUP_FILE"
            
            # Keep only last 7 backups
            ls -t backups/backup-*.sql.gz | tail -n +8 | xargs -r rm
          ENDSSH
      
      - name: Create .env.production file
        run: |
          cat > backend/.env.production << EOF
          DJANGO_SECRET_KEY=${{ secrets.DJANGO_SECRET_KEY_PRODUCTION }}
          DJANGO_DEBUG=False
          DJANGO_SETTINGS_MODULE=config.settings
          ALLOWED_HOSTS=api.podigger.perna.app
          CORS_ALLOWED_ORIGINS=https://podigger.perna.app
          
          DATABASE_HOST=db-production
          DATABASE_PORT=5432
          DATABASE_NAME=podigger_production
          DATABASE_USER=podigger_production
          DATABASE_PASSWORD=${{ secrets.DB_PASSWORD_PRODUCTION }}
          
          REDIS_URL=redis://redis-production:6379/1
          CELERY_BROKER_URL=redis://redis-production:6379/0
          CELERY_RESULT_BACKEND=redis://redis-production:6379/0
          
          SECURE_SSL_REDIRECT=True
          SESSION_COOKIE_SECURE=True
          CSRF_COOKIE_SECURE=True
          
          LOG_LEVEL=WARNING
          EOF
      
      - name: Create .env.production for frontend
        run: |
          cat > frontend/.env.production << EOF
          NEXT_PUBLIC_API_URL=https://api.podigger.perna.app
          NEXT_PUBLIC_ENVIRONMENT=production
          EOF
      
      - name: Copy files to VPS
        run: |
          ssh -o ServerAliveInterval=60 -o ServerAliveCountMax=10 ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} "mkdir -p /opt/podigger-production"
          rsync -avz --delete \
            -e "ssh -o ServerAliveInterval=60 -o ServerAliveCountMax=10" \
            --exclude '.git' \
            --exclude 'node_modules' \
            --exclude '.venv' \
            --exclude '__pycache__' \
            --exclude '.next' \
            --exclude 'backups' \
            ./ ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }}:/opt/podigger-production/
      
      - name: Deploy to production
        env:
          DB_PASSWORD_PRODUCTION: ${{ secrets.DB_PASSWORD_PRODUCTION }}
        run: |
          ssh -o ServerAliveInterval=60 -o ServerAliveCountMax=10 ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} "DB_PASSWORD_PRODUCTION='${DB_PASSWORD_PRODUCTION}'" bash -s << 'ENDSSH'
            cd /opt/podigger-production
            
            # Pull apenas imagens base (n√£o rebuildar tudo)
            docker compose -f docker-compose.production.yml pull db-production redis-production || true
            
            # Build sem --no-cache (usa cache de layers)
            docker compose -f docker-compose.production.yml build
            
            # Stop old containers (graceful shutdown)
            docker compose -f docker-compose.production.yml down --timeout 30
            
            # Start new containers
            docker compose -f docker-compose.production.yml up -d
            
            # Wait for backend to be healthy (retry adaptativo)
            echo "Waiting for backend to be healthy..."
            for i in {1..12}; do
              if docker compose -f docker-compose.production.yml exec -T backend-production curl -f http://localhost:8000/health/ 2>/dev/null; then
                echo "‚úÖ Backend is healthy"
                break
              fi
              if [ $i -eq 12 ]; then
                echo "‚ùå Backend failed to become healthy"
                exit 1
              fi
              echo "‚è≥ Waiting... (attempt $i/12)"
              sleep 5
            done
            
            # Run migrations
            docker compose -f docker-compose.production.yml exec -T backend-production python manage.py migrate --noinput
            
            # Collect static files
            docker compose -f docker-compose.production.yml exec -T backend-production python manage.py collectstatic --noinput
          ENDSSH
      
      - name: Health check
        run: |
          sleep 20
          
          # Check backend health (retry up to 3 times)
          for i in 1 2 3; do
            BACKEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://api.podigger.perna.app/health/ || echo "000")
            if [ "$BACKEND_STATUS" = "200" ]; then
              echo "‚úÖ Backend is healthy"
              break
            fi
            if [ $i -eq 3 ]; then
              echo "‚ùå Backend health check failed after 3 attempts (HTTP $BACKEND_STATUS)"
              exit 1
            fi
            echo "‚è≥ Backend not ready, retrying in 10s... (attempt $i/3)"
            sleep 10
          done
          
          # Check frontend health (retry up to 3 times)
          for i in 1 2 3; do
            FRONTEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://podigger.perna.app/ || echo "000")
            if [ "$FRONTEND_STATUS" = "200" ]; then
              echo "‚úÖ Frontend is healthy"
              break
            fi
            if [ $i -eq 3 ]; then
              echo "‚ùå Frontend health check failed after 3 attempts (HTTP $FRONTEND_STATUS)"
              exit 1
            fi
            echo "‚è≥ Frontend not ready, retrying in 10s... (attempt $i/3)"
            sleep 10
          done
      
      - name: Deployment summary
        if: success()
        run: |
          BRANCH="${{ github.event_name == 'workflow_dispatch' && inputs.branch || 'main' }}"
          echo "### üöÄ Production Deployment Successful" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Branch**: $BRANCH" >> $GITHUB_STEP_SUMMARY
          echo "**Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Triggered by**: ${{ github.event_name == 'push' && 'Automatic (merge to main)' || 'Manual' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Frontend**: https://podigger.perna.app" >> $GITHUB_STEP_SUMMARY
          echo "**Backend**: https://api.podigger.perna.app" >> $GITHUB_STEP_SUMMARY
          echo "**Deployed at**: $(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚ö†Ô∏è **Important**: Monitor the application for the next 30 minutes" >> $GITHUB_STEP_SUMMARY
      
      - name: Rollback on failure
        if: failure()
        env:
          DB_PASSWORD_PRODUCTION: ${{ secrets.DB_PASSWORD_PRODUCTION }}
        run: |
          echo "‚ö†Ô∏è Deployment failed, attempting rollback..."
          
          ssh -o ServerAliveInterval=60 -o ServerAliveCountMax=10 ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} "DB_PASSWORD_PRODUCTION='${DB_PASSWORD_PRODUCTION}'" bash -s << 'ENDSSH'
            cd /opt/podigger-production
            
            # Stop failed containers
            docker compose -f docker-compose.production.yml down
            
            # Restore from latest backup if exists
            LATEST_BACKUP=$(ls -t backups/backup-*.sql.gz 2>/dev/null | head -n 1)
            if [ -n "$LATEST_BACKUP" ]; then
              echo "üì¶ Restoring from backup: $LATEST_BACKUP"
              
              # Start only database
              docker compose -f docker-compose.production.yml up -d db-production
              sleep 10
              
              # Restore backup
              gunzip < "$LATEST_BACKUP" | docker compose -f docker-compose.production.yml exec -T db-production \
                psql -U podigger_production podigger_production
              
              echo "‚úÖ Database restored"
              
              # Try to start previous version
              git checkout HEAD~1 2>/dev/null || echo "‚ö†Ô∏è Could not checkout previous version"
              docker compose -f docker-compose.production.yml up -d
            else
              echo "‚ö†Ô∏è No backup found, database not restored"
            fi
          ENDSSH
          
          echo "### ‚ùå Production Deployment Failed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Rollback attempted**. Please check logs and restore manually if needed." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Action required**: Investigate failure and redeploy when ready." >> $GITHUB_STEP_SUMMARY
